# Условие
## Tone
Напишете клас Tone, който да описва понятието за музикален тон. Искаме да може да се инстанцира по следния начин:  
#### c_sharp = Tone("C#")

Искаме да имаме стрингова репрезентация на тоновете, работеща по следния начин:      
#### print(str(c_sharp))  

Уговорка: Няма да се занимаваме с октавите на дадените тонове, приемаме, че всички тонове C са едно и също.

## Interval
Напишете клас Interval, който да описва понятието за интервал. Искаме да може да се инстанцира по следния начин:    
#### number_of_semitones = 3  
#### minor_third = Interval(number_of_semitones)

Искаме да имаме стрингова репрезентация на интервалите, работеща по следния начин:       
#### print(str(minor_third)) 

Уговорка: Интервалите могат да приемат произволни естествени числа, като Interval(13) е същото като Interval(1) и неговата репрезентация би била minor 2nd. С други думи отново се абстрахираме от октавите.

## Chord
Напишете клас Chord, който да описва понятието за акорд. Искаме да може да се инстанцира по следния начин:
#### c, d_sharp, g = Tone("C"), Tone("D#"), Tone("G")
#### c_minor_chord = Chord(c, d_sharp, g)

Имаме следните уговорки:

 - Първият параметър при инстанциране винаги е основния тон (позиционен).
 - Останалите тонове са произволен брой и с произволна подредба. За подредбата повече информация малко по-надолу.
 - Повторенията на тоновете не се отразяват. С други думи дори да имате 10 пъти C - пази се единствено информация за тона C (важно за долната подточка).
 - Приемаме опит за създаване на акорд от 1 тон за недефинирано поведение и искаме да се възбуди TypeError с текст "Cannot have a chord made of only 1 unique tone".

Искаме да имаме стрингова репрезентация на акордите, работеща по следния начин:  
#### print(str(c_minor_chord))  # Output: "C-D#-G"

## Chord.is_minor
Ако акордът има в себе си тон, който заедно с основният (root) образува "minor 3rd" - той е минорен и функцията трябва да ни върне True. В противен случай - False

## Chord.is_major
Ако акордът има в себе си тон, който заедно с основният (root) образува "major 3rd" - той е мажорен и функцията трябва да ни върне True. В противен случай - False

## Chord.is_power_chord
Ако акордът няма в себе си тон, който заедно с основният (root) образува "minor 3rd", нито пък "major 3rd" - той е power акорд и функцията трябва да ни върне True. В противен случай - False

# Операции
## Събиране на тонове
Искаме да можем да събираме обекти от клас Tone и резултат от операцията да бъде обект от клас Chord

## Изваждане на тонове
Искаме да можем да изваждаме обекти от клас Tone и резултат от операцията да бъде обект от клас Interval

## Събиране на тон с интервал
Искаме да можем да събираме тонове с интервали и резултат от операцията да бъде нов тон с променена височина

## Изваждане на интервал от тон
Искаме да можем да изваждаме интервал от тон и резултат от операцията да бъде нов тон с променена височина, но този път в обратна посока, т.е. "надолу"

## Събиране на интервали
Искаме да можем да събираме обекти от клас Interval и резултат от операцията да бъде нов обект от клас Interval

## Събиране на акорд с тон
Искаме да можем да събираме акорди с тонове и резултат от операцията да бъде нов акорд

## Изваждане на тон от акорд
Искаме да можем да изваждаме тон от акорд. Ако акордът съдържа три или повече, тона ще се върне нов акорд, в противен случай ще го третираме като недефинирано поведение и искаме да се възбуди TypeError с текст "Cannot have a chord made of only 1 unique tone".

## Събиране на акорди
Искаме да можем да събираме обекти от клас Chord и резултат от операцията да бъде нов обект от клас Chord

## Chord.transposed
Искаме да можем да "транспонираме" даден акорд, т.е. да изместим всеки един от тоновете му с един и същ интервал. Интервалът в нашият случай ще бъде обект от тип Interval, а промяната на тоновете следва да може да се случва както нагоре, така и надолу, определено от знака пред интервала. Тъй като методът е transposed - искаме като резултат да ни връща нов обект от тип Chord.
